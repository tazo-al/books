# 01. 리액트 개발을 위해 꼭 알아야 할 자바스크립트

- 단순히 리액트 코드를 작성하는 것이 아닌 리액트가 수행하는 작업을 이해하기 위한 최소한의 자바스크립트를 다룬다.

## 1.1 자바스크립트의 동등 비교

- 동등 비교를 배우는 이유는 가상 DOM과 실제 DOM의 비교, 컴포넌트가 렌더링할지 판단하는 방법, 변수나 함수의 메모이제이션 등을 자바스크립트의 동등 비교를 기반으로 하기 때문이다.

### 1.1.1 자바스립트의 데이터 타입

#### 원시 타입

- undefined

  - 선언 후 값을 할당하지 않은 변수, 값이 주어지지 않은 인수에 자동으로 할당되는 값.

- null

  - 값이 없거나 비어있는 값을 표현할 때 사용.
  - 특이한 점으로 `typeof null`을 하면 `object`가 반환된다.
  - `undefined`는 선언을 했지만 할당되지 않은 값, `null`은 명시적으로 비어있는 값을 표현할 때 일반적으로 사용한다.

- Boolean

  - `true` 또는 `false`만 갖을 수 있는 데이터 타입.
  - 자바스크립트에서는 조건문 내부에서 `true`로 판단되는 `truthly`, `false`로 판단되는 `falsy`가 있다.
  - `falsey`는 `false`, 0(`0`, `-0`), `NaN`, 빈 문자열("", '', ``), `undefined`, `null`이 있다.
  - `truthly`는 `falsy`를 제외한 모든 것으로 배열이나 객체일 경우 요소가 비어있어도 `true`로 취급한다.

- Number

  - `-(2^53 - 1) ~ 2^53 -1`까지의 숫자를 표현할 수 있다.
  - ES6 이전에 유일하게 숫자를 나타내는 데이터 타입으로 정수와 실수를 구분하지 않고 2진수, 8진수, 16진수 등의 별도 데이터 타입을 제공하지 않으므로 모두 10진수로 표현한다.

- Bigint

  - ES2020에 새롭게 추가된 숫자형으로 `number`에서 표현할 수 있는 숫자보다 더 큰 범위의 숫자를 갖을 수 있다.

- String

  - 텍스트 타입의 데이터를 표현하는 데이터 타입으로 한 번 선언된 문자열은 불변성을 갖는다.
  - '', ""와 달리 ``는 템플릿 리터럴이라고 불리며 내부에서 줄바꿈, 표현식을 사용할 수 있다.

- Symbol
  - ES6에 새로 추가된 타입으로 중복되지 않은 고유한 값을 나타내는 데이터 타입으로 반드시 `Symbol()`을 사용해야만 한다.

#### 객체 타입

- 원시 타입를 제외한 모든 데이터 타입으로 클래스, 배열, 함수, 정규식 등이 있다.
- 참조를 전달하여 참조형 데이터라고도 불리며 여기서 자바스크립트 동등 비교의 특징이 나타난다.

### 1.1.2 값을 저장하는 방식의 차이

- 원시 타입과 객체 타입의 가장 큰 차이점은 값을 저장하는 방식으로 동등 비교를 할 때 차이를 만드는 원인이 된다.
- 원시 타입: 불변 형태의 값으로 저장되며 복사 시에 값을 복사하여 전달한다.
- 객체 타입: 변경 가능한 상태로 저장되며 복사 시에 값이 아닌 참조를 전달한다.

  - 객체 간의 비교는 대부분 `true`가 아닐 수 있다는 것을 인지해야 한다.

  ```js
  console.log([1, 2, 3] === [1, 2, 3]); // false

  const objA = { comment: "hi" };
  const objB = objA;
  console.log(objA === objB); // true
  ```

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is

- 두 개의 인수를 받아 두 개가 동일한지 확인하고 반환하는 메서드
- `==`와의 차이점: `==`는 비교 전에 강제 타입 변환이 일어나지만 `Object.is`는 강제 타입 변환이 이뤄지지 않는다.
- `===`와의 차이점: `===`는 `0`과 `-0`, `NaN`과 `NaN`을 비교하지 못하지만 `Object.is`는 정확히 비교해준다.
- 주의할 점으로 객체는 정확하게 비교하지 못한다.

### 1.1.4 리액트에서의 동등 비교

- 리액트에서는 `Object.is`를 사용하여 동등 비교를 한다.
- 리액트에서 동등 비교 시 사용하는 `shallowEqual`의 비교 과정은 아래와 같다.
  - `Object.is`로 먼저 비교를 수행한다.
  - 객체의 얕은 비교를 수행, 얕은 비교란 첫 번째 깊이에 존재하는 값만 비교한다는 의미다.
- 객체의 얕은 비교를 수행하는 이유는 `JSX`의 `props`는 객체이고, `props`만 일차적으로 비교하면 되기 때문이다.
- 이러한 특징을 안다면 `props`에 또 다른 객체를 넘겨줄 때 리액트 렌더링이 예상치 못하게 작동한다는 것을 알 수 있다.

  ```jsx
  import { memo, useEffect, useState } from "react";
  import "./styles.css";

  const Component = memo((props) => {
    useEffect(() => {
      console.log("Component 렌더됨!");
    });

    return <h1>{props.counter}</h1>;
  });

  const DeeperComponent = memo((props) => {
    useEffect(() => {
      console.log("DeeperComponent 렌더됨!");
    });

    return <h1>{props.counter.counter}</h1>;
  });

  export default function App() {
    const [, setCounter] = useState(0);

    function handleClick() {
      setCounter((prev) => prev + 1);
    }

    return (
      <div className="App">
        <Component counter={100} />
        <DeeperComponent counter={{ counter: 100 }} />
        <button onClick={handleClick}>+</button>
      </div>
    );
  }
  ```

  ![DeeperComponent의 props가 변경되지 않았음에도 버튼 클릭 시 렌더링이 되고 있다](./01-1.png)

  - DeeperComponent의 props가 변경되지 않았음에도 버튼 클릭 시 렌더링이 되고 있다

- 만약 내부에 있는 객체까지 재귀함수로 깊은 비교한다면 성능에 악영향을 미칠 것이다.

### 1.1.5 정리

- 자바스크립트에서 객체 비교의 불완전성을 잘 숙지하면 훅의 의존성 배열의 비교, 렌더링 방지를 넘어선 `useMemo`와 `useCallback`의 필요성, 렌더링 최적화를 위해서 꼭 필요한 `React.memo`를 올바르게 작동시키기 위해 고려해야 할 것들을 이해할 수 있다.

## 1.2 함수

- 함수의 다양한 형태와 차이점이 무엇인지 살펴보자.

### 함수란 무엇인가?

- 작업을 수행하거나 값을 계산하는 과정을 표현하고 하나의 블럭으로 감싸 실행 단위로 만들어 놓은 것.
- 리액트의 함수형 컴포넌트
  - 함수형 컴포넌트를 `JSX` 문법으로 사용하면 단일 단위로 `props`를 받거나 전개 연산자로 받을 수 있음.
  - 일반 함수처럼 사용할 수도 있다.

### 함수를 정의하는 4가지 방법

#### 함수 선언문

- 선언문은 말 그대로 선언한 것으로 어떠한 값도 표현하지 않아 변수에 할당할 수 없는 것처럼 보이지만 할당할 수 있다.
- 이는 자바스크립트 엔진이 코드의 문맥에 따라 동일한 함수를 문이 아닌 표현식으로 해석하는 경우가 있기 때문이다.

#### 함수 표현식

- 일급 객체: 자바스크립트의 함수는 일급 객체로 함수의 매개변수가 될 수 있고 반환값이 될 수도 있으며 할당할 수도 있다.
- 함수 표현식에서는 이름을 붙이지 않는 것이 일반적이다.
- 호이스팅에서 차이점을 나타낸다.
  - 선언문: 호이스팅이 되어 선언문 전에 호출을 하더라도 사용할 수 있다.
  - 표현식: 호이스팅이 되는 시점에 `undefined`로 초기화 되고 런타임에 함수가 할당된다.

#### Function 생성자

- 권장되지 않는 방식이다.

#### 화살표 함수

- `constructor`를 갖고 있지 않아서 생성자 함수로 사용할 수 없다.
- `arguments`를 갖고 있지 않다.
- `this binding`을 하지 않고 상위 스코프의 `this`를 그대로 사용한다.

### 다양한 함수 살펴보기

#### 즉시 실행 함수

- 함수를 정의함과 동시에 실행한다.
- 한 번 실행 후 재 호출이 불가능하여 이름을 붙이지 않는 것이 일반적이다.
- 독립적인 함수 스코프를 운용할 수 있다는 장점이 있다.
- 읽는 이로 하여금 다시 실행되지 않는 다는 점을 각인시킬 수 있다.
- 재사용되지 않고 한 번만 실행되는 함수라면 즉시 실행 함수의 사용을 검토해보자.

#### 고차 함수

- 일급 객체의 특성을 살려 함수를 인수로 받거나 반환하는 역할을 하는 함수.
- 리액트의 함수형 컴포넌트도 동일한 방법으로 고차 컴포넌트를 만들 수 있다(3.2에서 다룰 예정).

### 함수 사용 시 주의할 점

#### 함수의 부수 효과(side-effect)를 최대한 억제하라

- 순수 함수: 언제 어디서든 동일한 인수를 받아 동일한 값을 반환하는 함수로 예측 가능하다는 장점이 있다.
- 모든 함수를 순수 함수로 작성할 수는 없다.
- API 호출, 콘솔 등이 모두 부수 효과다.
- 부수 효과를 최대한 줄이는 방법으로 작성해야 한다.
- 리액트에서 부수 효과를 관리하는 `useEffect`를 최소한으로 줄이자.

#### 가능한 한 함수를 적게 만들어라

> 함수는 하나의 일을, 그 하나만 잘하면 된다. - 더글라스 매킬로이

- 코드가 길어질 수록 코드 냄새(문제를 일으킬 여지가 있는 코드)가 나고 내부 로직을 파악하기 어려워진다.
- 요점은 하나의 함수가 많은 일을 하지 않게 하는 것이다.

#### 누구나 이해할 수 있는 이름을 붙여라

- `Terser`를 사용하면 한글로 변수명, 함수명을 작성할 수 있다.
- 리액트에서 `useEffect`, `useCallback` 등 훅의 `callback` 함수에 이름을 붙이면 안에 내용을 확인하지 않아도 어떤 일을 하는지 알 수 있고 디버깅도 편해진다.

### 정리

- 함수를 이해하기 위해서는 알아둬야 할 것이 많고, 다양한 예외들이 있으므로 잘 숙지해야 한다.

## 1.3 클래스

## 1.4 클로저

## 1.5 이벤트 루프의 비동기 통신의 이해

## 1.6 리액트에서 자주 사용하는 자바스크립트 문법

## 1.7 선택이 아닌 필수, 타입스크립트
